<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">
<link rel="manifest" href="manifest.json">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=arrow_insert" />
<title>Textarea</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html {
    color-scheme: light dark;
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;

    background-color: #fff;
    --elevated: #fff;
    --link: #0066cc;
    --text: #161616;
    --outline: #007aff;

    @media (prefers-color-scheme: dark) {
      background-color: #000;
      --elevated: #121212;
      --link: #58a6ff;
      --text: #fff;
    }
  }

  body {
    color: var(--text);
    font-family: "Poppins", sans-serif;
  }

  a {
    color: var(--link);
    text-decoration: underline;
    text-underline-offset: 4px;
    text-decoration-thickness: 1px;
  }

  article {
    outline: none;
    padding: 18px max(18px, calc(50vw - 400px));
    width: 100%;
    min-height: 100dvh;
    font: 18px / 1.5 "Poppins", sans-serif;
    tab-size: 4;
    white-space: pre-wrap;
    text-wrap-style: stable;
    overflow-wrap: break-word;
  }

  .md-h1,
  .md-h2,
  .md-h3,
  .md-h4,
  .md-h5,
  .md-h6 {
    font-weight: 700;
  }

  .md-h1 {
    font-size: 2em;
  }

  .md-h2 {
    font-size: 1.5em;
  }

  .md-h3 {
    font-size: 1.25em;
  }

  .md-h4 {
    font-size: 1.1em;
  }

  .md-h5 {
    font-size: 1em;
  }

  .md-h6 {
    font-size: 0.9em;
  }

  .md-code {
    font-family: monospace;
  }

  .md-codeblock {
    font-family: monospace;
  }

  .md-bold {
    font-weight: bold;
  }

  .md-strike {
    text-decoration: line-through;
  }

  .md-italic {
    font-style: italic;
  }

  .md-url {
    cursor: pointer;
  }

  .md-img {
    max-width: 100%;
    height: auto;
    vertical-align: middle;
  }

  .md-hr {
    border: none;
    border-top: 1px solid currentColor;
    opacity: 0.3;
    margin: 1em 0;
  }

  .md-ul, .md-ol {
    margin: 0.5em 0;
    padding-left: 1.5em;
  }

  .md-ol { list-style-type: decimal; }
  .md-ul { list-style-type: disc; }

  .md-li {
    margin: 0.2em 0;
  }

  .md-blockquote {
    border-left: 4px solid currentColor;
    opacity: 0.7;
    margin: 0.5em 0;
    padding-left: 1em;
  }

  .md-table {
    border-collapse: collapse;
    margin: 0.5em 0;
    width: 100%;
  }

  .md-table th,
  .md-table td {
    border: 1px solid currentColor;
    padding: 6px 10px;
    text-align: left;
  }

  .md-table th {
    font-weight: 600;
  }

  .md-table tr:nth-child(1) th,
  .md-table tr:nth-child(2) td {
    border-bottom-width: 2px;
  }

  #button {
    -webkit-tap-highlight-color: transparent;
    background-color: #0569fa;
    border-radius: 50%;
    border: none;
    bottom: 15px;
    box-shadow: 0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, .12);
    color: #fff;
    cursor: pointer;
    display: grid;
    font-weight: 600;
    width: 46px;
    height: 46px;
    outline: none;
    overflow: hidden;
    padding: 0;
    place-items: center;
    position: fixed;
    right: 15px;
    text-decoration: none;
    touch-action: manipulation;
    transition: background-color .3s ease-out;
    user-select: none;
    z-index: 1;
  }

  @media (hover) {
    #button:hover {
      color: #fff;
      background-color: #3c86f3;
      box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, .12);
    }
  }

  #button:focus-visible {
    outline: 2px solid var(--outline);
    outline-offset: 2px;
  }

  span.ripple {
    position: absolute;
    border-radius: 50%;
    transform: scale(0);
    animation: ripple 600ms linear;
    background-color: rgba(255, 255, 255, 0.7);
  }

  @keyframes ripple {
    to {
      transform: scale(4);
      opacity: 0;
    }
  }

  #menu {
    visibility: hidden;
    transform: scale(0.9) translateY(20px);
    transition: all 100ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
    opacity: 0;
    display: flex;
    flex-direction: column;
    width: 220px;
    position: fixed;
    right: 16px;
    bottom: 77px;
    box-shadow: 0 19px 38px rgba(0, 0, 0, 0.10), 0 15px 12px rgba(0, 0, 0, 0.05);
    background: var(--elevated);
    backdrop-filter: blur(10px);
    border-radius: 10px;
    z-index: 2;
  }

  #menu.visible {
    opacity: 1;
    transform: scale(1) translateY(0);
    visibility: visible;
  }

  #menu .item {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    text-decoration: none;
    text-align: left;
    padding: 10px 14px;
    overflow: hidden;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    outline: none;
    border: none;
    touch-action: manipulation;
    font: 16px / 1.5 "Poppins", sans-serif;
    color: var(--text);
  }

  #menu .item:hover {
    background-color: rgba(0, 0, 0, 0.04);
    @media (prefers-color-scheme: dark) {
      background-color: #353535;
    }
  }

  #menu .item:focus-within {
    outline: 2px solid var(--outline);
  }

  #menu .item:first-child {
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
  }

  #menu .item:last-child {
    border-bottom-left-radius: 10px;
    border-bottom-right-radius: 10px;
  }

  #notification {
    visibility: hidden;
    transform: translateY(-30px);
    transition: all 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
    opacity: 0;

    display: flex;
    flex-direction: column;

    position: fixed;
    right: 17px;
    top: 17px;

    background: #5ad227;
    color: #fff;
    border-radius: 30px;
    font: 18px / 1 "Poppins", sans-serif;
    font-weight: 600;
    z-index: 2;
    padding: 10px 20px;
  }

  #notification.visible {
    opacity: 1;
    transform: translateY(0);
    visibility: visible;
  }

  @media print {
    .noprint {
      visibility: hidden !important;
    }
  }

  #raw-view {
    display: none;
    width: 100%;
    min-height: 100dvh;
    padding: 18px max(18px, calc(50vw - 400px));
    font: 18px / 1.5 "Poppins", sans-serif;
    tab-size: 4;
    white-space: pre-wrap;
    overflow-wrap: break-word;
    outline: none;
    border: none;
    resize: none;
    background: transparent;
    color: var(--text);
  }

  body.view-raw article {
    display: none;
  }

  body.view-raw #raw-view {
    display: block;
  }

  #breadcrumb {
    padding: 8px max(18px, calc(50vw - 400px));
    font: 14px / 1.4 "Poppins", sans-serif;
  }

  #breadcrumb a {
    color: var(--link);
    text-decoration: none;
    text-underline-offset: 4px;
  }

  #breadcrumb a:hover {
    text-decoration: underline;
  }

  #breadcrumb .sep {
    color: var(--text);
    opacity: 0.5;
    margin: 0 4px;
    pointer-events: none;
  }

  #breadcrumb.hidden {
    display: none;
  }

  #referenced-by {
    padding: 12px max(18px, calc(50vw - 400px));
    font: 14px / 1.4 "Poppins", sans-serif;
    border-top: 1px solid rgba(0,0,0,0.08);
    margin-top: 24px;
  }

  #referenced-by.hidden {
    display: none;
  }

  #referenced-by a {
    color: var(--link);
    text-decoration: none;
  }

  #referenced-by a:hover {
    text-decoration: underline;
  }

  #referenced-by .label {
    opacity: 0.7;
    margin-bottom: 6px;
  }

  body.view-raw #referenced-by {
    border-top: none;
  }

  .ref-indicator {
    display: inline-flex;
    align-items: center;
    vertical-align: super;
    font-size: 0.72em;
    opacity: 0.6;
    margin-left: 1px;
    line-height: 1;
  }

  .ref-indicator .material-symbols-outlined {
    font-size: 1em;
    transform: rotate(90deg);
    transform-origin: center;
  }

  #button.hidden {
    display: none;
  }

  .poppins-thin { font-family: "Poppins", sans-serif; font-weight: 100; font-style: normal; }
  .poppins-extralight { font-family: "Poppins", sans-serif; font-weight: 200; font-style: normal; }
  .poppins-light { font-family: "Poppins", sans-serif; font-weight: 300; font-style: normal; }
  .poppins-regular { font-family: "Poppins", sans-serif; font-weight: 400; font-style: normal; }
  .poppins-medium { font-family: "Poppins", sans-serif; font-weight: 500; font-style: normal; }
  .poppins-semibold { font-family: "Poppins", sans-serif; font-weight: 600; font-style: normal; }
  .poppins-bold { font-family: "Poppins", sans-serif; font-weight: 700; font-style: normal; }
  .poppins-extrabold { font-family: "Poppins", sans-serif; font-weight: 800; font-style: normal; }
  .poppins-black { font-family: "Poppins", sans-serif; font-weight: 900; font-style: normal; }
  .poppins-thin-italic { font-family: "Poppins", sans-serif; font-weight: 100; font-style: italic; }
  .poppins-extralight-italic { font-family: "Poppins", sans-serif; font-weight: 200; font-style: italic; }
  .poppins-light-italic { font-family: "Poppins", sans-serif; font-weight: 300; font-style: italic; }
  .poppins-regular-italic { font-family: "Poppins", sans-serif; font-weight: 400; font-style: italic; }
  .poppins-medium-italic { font-family: "Poppins", sans-serif; font-weight: 500; font-style: italic; }
  .poppins-semibold-italic { font-family: "Poppins", sans-serif; font-weight: 600; font-style: italic; }
  .poppins-bold-italic { font-family: "Poppins", sans-serif; font-weight: 700; font-style: italic; }
  .poppins-extrabold-italic { font-family: "Poppins", sans-serif; font-weight: 800; font-style: italic; }
  .poppins-black-italic { font-family: "Poppins", sans-serif; font-weight: 900; font-style: italic; }
</style>
<div id="breadcrumb" class="noprint"></div>
<article contenteditable="false" spellcheck="false"></article>
<div id="referenced-by" class="noprint hidden"></div>
<textarea id="raw-view" spellcheck="true" placeholder="Markdownâ€¦"></textarea>
<button id="button" class="noprint hidden" aria-hidden="true">
  <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
       stroke="currentColor"
       stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="1"></circle>
    <circle cx="12" cy="5" r="1"></circle>
    <circle cx="12" cy="19" r="1"></circle>
  </svg>
</button>
<div id="menu" class="noprint" role="menu">
  <a class="item" href="#new" target="_blank" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-plus"></use>
    </svg>
    New document
  </a>
  <a class="item" id="qr" href="/qr" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-qrcode"></use>
    </svg>
    Generate QR code
  </a>
  <a class="item" id="share-link" href="" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-share"></use>
    </svg>
    Share document
  </a>
  <a class="item" id="save-as-html" href="" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-empty"></use>
    </svg>
    Save as HTML
  </a>
  <a class="item" id="save-as-text" href="" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-empty"></use>
    </svg>
    Save as TEXT
  </a>
  <a class="item" id="all-pages" href="#" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-empty"></use>
    </svg>
    All pages
  </a>
  <a class="item" href="https://github.com/antonmedv/textarea" target="_blank" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-github"></use>
    </svg>
    GitHub
  </a>
</div>
<div id="notification" class="noprint"></div>
<div id="pages-modal" class="noprint" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.5);z-index:10;align-items:center;justify-content:center;flex-direction:column;">
  <div style="background:var(--elevated);border-radius:12px;padding:24px;max-width:400px;width:90%;max-height:70vh;overflow:auto;">
    <h3 style="margin:0 0 16px;">All pages</h3>
    <div id="pages-list"></div>
    <button id="pages-modal-close" style="margin-top:16px;padding:8px 16px;">Close</button>
  </div>
</div>
<script src="config.js"></script>
<script>
  initUI()

  const article = document.querySelector('article')
  const rawView = document.querySelector('#raw-view')
  let viewMode = 'r'

  const editor = new Editor(article, parseMarkdown)
  article.addEventListener('input', debounce(500, save))
  article.addEventListener('blur', save)
  article.addEventListener('click', event => {
    const a = event.target.closest('a')
    if (!a) return
    if (a.classList.contains('wiki-link')) {
      event.preventDefault()
      const href = a.getAttribute('href') || ''
      let slug = a.getAttribute('data-wiki-slug')
      if (!slug && href.startsWith('#/')) {
        try {
          slug = decodeURIComponent(href.slice(2))
        } catch (_) {
          slug = href.slice(2)
        }
      }
      if (!slug) return
      if (!SUPABASE && currentPageSlug !== slug) {
        const idx = navigationPath.indexOf(slug)
        if (idx >= 0) navigationPath = navigationPath.slice(0, idx + 1)
        else navigationPath = [...navigationPath, slug]
      }
      location.hash = '#/' + encodeURIComponent(slug)
    } else {
      window.open(a.getAttribute('href'), '_blank')
    }
  })
  rawView.addEventListener('input', debounce(500, save))
  rawView.addEventListener('keydown', handleRawKeydown)
  rawView.addEventListener('input', handleRawInputForWikilink)
  rawView.addEventListener('blur', save)

  addEventListener('DOMContentLoaded', load)
  addEventListener('hashchange', load)
  addEventListener('load', () => new MutationObserver(save).observe(article, {attributeFilter: ['style']}))
  addEventListener('keydown', e => {
    if ((e.metaKey || e.ctrlKey) && e.code === 'KeyS') {
      e.preventDefault()
      if (e.shiftKey) downloadMD()
      else save()
    }
    if ((e.metaKey || e.ctrlKey) && e.code === 'KeyE') {
      e.preventDefault()
      toggleView()
    }
  })
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js')
  }

  console.log('%cGitHub https://github.com/antonmedv/textarea', 'font-size: 16px; border: 1px solid lightblue; border-radius: 12px; padding: 10px 14px; ')

  function notify(message) {
    const n = document.querySelector('#notification')
    if (n) {
      n.classList.add('visible')
      n.textContent = message
      setTimeout(() => n.classList.remove('visible'), 2000)
    }
  }

  const pagesCache = new Map()
  let currentPageSlug = 'Home'
  let navigationPath = ['Home']

  const SUPABASE = (() => {
    const cfg = window.SUPABASE_CONFIG
    if (!cfg?.url || !cfg?.anonKey) return null
    const base = `${cfg.url}/rest/v1/pages`
    const headers = {
      'apikey': cfg.anonKey,
      'Authorization': `Bearer ${cfg.anonKey}`,
      'Content-Type': 'application/json',
      'Prefer': 'return=representation'
    }
    return {
      async get(slug) {
        const res = await fetch(`${base}?slug=eq.${encodeURIComponent(slug)}&limit=1`, { headers })
        if (!res.ok) throw new Error(res.statusText)
        const rows = await res.json()
        const row = rows[0] ?? null
        if (row) pagesCache.set(row.slug, row)
        return row
      },
      async upsert(slug, title, content, parent_slug) {
        const body = { slug, title, content, updated_at: new Date().toISOString() }
        if (parent_slug !== undefined) body.parent_slug = parent_slug || null
        const res = await fetch(`${base}?on_conflict=slug`, {
          method: 'POST',
          headers: { ...headers, 'Prefer': 'resolution=merge-duplicates,return=representation' },
          body: JSON.stringify(body)
        })
        if (!res.ok) {
          const err = await res.json().catch(() => ({}))
          throw new Error(err.message || res.statusText)
        }
        const rows = await res.json()
        const row = rows[0] ?? null
        if (row) pagesCache.set(row.slug, row)
        return row
      },
      async list() {
        const res = await fetch(`${base}?select=slug,title,parent_slug,updated_at&order=updated_at.desc`, { headers })
        if (!res.ok) throw new Error(res.statusText)
        const rows = await res.json()
        rows.forEach(r => pagesCache.set(r.slug, r))
        return rows
      },
      async getParentChain(slug) {
        const chain = []
        let current = slug
        while (current) {
          const row = await this.get(current)
          if (!row) break
          chain.unshift(row)
          current = row.parent_slug || null
        }
        return chain
      },
      async findReferrers(slug) {
        const res = await fetch(`${base}?select=slug,title,content&limit=500`, { headers })
        if (!res.ok) throw new Error(res.statusText)
        const rows = await res.json()
        rows.forEach(r => pagesCache.set(r.slug, { ...pagesCache.get(r.slug), ...r }))
        const needle = '[[' + slug + ']]'
        return rows.filter(p => (p.content || '').includes(needle))
      },
      async getReferencedSlugs() {
        const res = await fetch(`${base}?select=content&limit=500`, { headers })
        if (!res.ok) return new Set()
        const rows = await res.json()
        const set = new Set()
        const re = /\[\[([^\]]+?)(?:\|[^\]]+)?\]\]/g
        rows.forEach(p => {
          let m
          const content = p.content || ''
          re.lastIndex = 0
          while ((m = re.exec(content)) !== null) set.add(m[1].trim())
        })
        return set
      }
    }
  })()

  let referencedSlugsSet = new Set()

  function parseHash(hash) {
    if (!hash || hash.length < 2) return { mode: 'wiki', view: 'r', payload: '', pageSlug: 'Home' }
    if (hash.startsWith('#/')) {
      const slug = decodeURIComponent(hash.slice(2).replace(/^\/+/, ''))
      return { mode: 'wiki', view: 'r', payload: '', pageSlug: slug || 'Home' }
    }
    const c = hash[1]
    if (c === 'r' || c === 'e') return { mode: 'legacy', view: c, payload: hash.slice(2) }
    return { mode: 'wiki', view: 'r', payload: '', pageSlug: decodeURIComponent(hash.slice(1)) || 'Home' }
  }

  function slugFromHash(hash) {
    const p = parseHash(hash)
    return p.mode === 'wiki' ? (p.pageSlug || 'Home') : null
  }

  function setView(mode) {
    viewMode = mode
    document.body.classList.toggle('view-raw', mode === 'e')
    document.body.classList.toggle('view-rendered', mode === 'r')
    if (mode === 'e') rawView.focus()
    else article.focus()
  }

  async function toggleView() {
    if (viewMode === 'r') {
      rawView.value = getArticleMarkdown()
      setView('e')
    } else {
      editor.set(rawView.value)
      setView('r')
    }
    const hash = await get()
    history.replaceState({}, '', hash)
    await save()
    updateTitle()
  }

  async function load() {
    try {
      if (location.hash !== '') {
        await set(location.hash)
      } else {
        const stored = localStorage.getItem('wiki_hash') ?? ''
        await set(stored || '#/Home')
        const hash = await get()
        if (hash !== location.hash) history.replaceState({}, '', hash)
      }
    } catch (e) {
      article.textContent = ''
      rawView.value = ''
      article.removeAttribute('style')
      if (typeof notify === 'function') notify('Error: ' + e.message)
    }
    updateTitle()
  }

  async function save() {
    const hash = await get()
    if (location.hash !== hash) history.replaceState({}, '', hash)
    try {
      localStorage.setItem('wiki_hash', hash)
    } catch (e) {
    }
    const slug = slugFromHash(hash) || currentPageSlug
    if (slug) {
      const content = viewMode === 'r' ? getArticleMarkdown() : rawView.value
      const match = content.match(/^\n*#\s*(.+)\n/)
      await persistToBackend(slug, content, match?.[1] ?? slug)
    }
    updateTitle()
  }

  async function set(hash) {
    if (!hash) return
    const parsed = parseHash(hash)
    if (parsed.mode === 'wiki' && SUPABASE) {
      const slug = parsed.pageSlug || 'Home'
      currentPageSlug = slug
      setView(parsed.view)
      try {
        referencedSlugsSet = await SUPABASE.getReferencedSlugs()
        await SUPABASE.list()
        const row = await SUPABASE.get(currentPageSlug)
        const content = row?.content ?? ''
        const title = row?.title ?? ''
        editor.set(content)
        rawView.value = content
        article.removeAttribute('style')
        if (row) pagesCache.set(row.slug, row)
        const chain = await SUPABASE.getParentChain(slug)
        navigationPath = chain.map(r => r.slug)
      } catch (e) {
        referencedSlugsSet = new Set()
        editor.set('')
        rawView.value = ''
        navigationPath = [slug]
        if (typeof notify === 'function') notify('Could not load page')
      }
      renderBreadcrumb()
      renderReferencedBy()
      return
    }
    if (parsed.mode === 'legacy') {
      let content = ''
      let style = null
      if (parsed.payload) {
        try {
          const decoded = (await decompress(parsed.payload)).split('\x00')
          content = decoded[0] ?? ''
          style = decoded[1] ?? null
        } catch (_) {
        }
      }
      editor.set(content)
      rawView.value = content
      if (style) article.setAttribute('style', style)
      else article.removeAttribute('style')
      setView(parsed.view)
      currentPageSlug = null
      navigationPath = []
      renderBreadcrumb()
      renderReferencedBy()
      return
    }
    if (parsed.mode === 'wiki' && !SUPABASE) {
      const slug = parsed.pageSlug || 'Home'
      const stored = localStorage.getItem('wiki:' + slug) ?? ''
      currentPageSlug = slug
      const idx = navigationPath.indexOf(slug)
      if (idx >= 0) navigationPath = navigationPath.slice(0, idx + 1)
      else navigationPath = [slug]
      editor.set(stored)
      rawView.value = stored
      article.removeAttribute('style')
      setView(parsed.view)
      renderBreadcrumb()
      renderReferencedBy()
      return
    }
  }

  async function get() {
    const slug = slugFromHash(location.hash)
    if (slug) return '#/' + encodeURIComponent(slug)
    const style = article.getAttribute('style')
    const content = (viewMode === 'r' ? getArticleMarkdown() : rawView.value) + (style !== null ? '\x00' + style : '')
    return '#' + viewMode + await compress(content)
  }

  async function persistToBackend(slug, content, title, parent_slug) {
    if (SUPABASE && slug) {
      try {
        const row = await SUPABASE.upsert(slug, title || slug, content, parent_slug)
        if (row) pagesCache.set(row.slug, row)
      } catch (e) {
        if (typeof notify === 'function') notify('Could not save: ' + e.message)
      }
    } else if (slug) {
      try {
        localStorage.setItem('wiki:' + slug, content)
      } catch (_) {}
    }
  }

  function updateTitle() {
    const content = viewMode === 'r' ? getArticleMarkdown() : rawView.value
    const match = content.match(/^\n*#\s*(.+)\n/)
    document.title = match?.[1] ?? 'Textarea'
  }

  async function renderReferencedBy() {
    const el = document.querySelector('#referenced-by')
    if (!el) return
    if (!SUPABASE || !currentPageSlug) {
      el.classList.add('hidden')
      el.innerHTML = ''
      return
    }
    try {
      const referrers = await SUPABASE.findReferrers(currentPageSlug)
      if (!referrers.length) {
        el.classList.add('hidden')
        el.innerHTML = ''
        return
      }
      el.classList.remove('hidden')
      el.innerHTML = '<div class="label">Referenced by</div>'
      referrers.forEach(p => {
        const a = document.createElement('a')
        a.href = '#/' + encodeURIComponent(p.slug)
        a.textContent = p.title || p.slug
        a.className = 'wiki-link md-url'
        a.style.display = 'block'
        a.style.marginBottom = '4px'
        el.appendChild(a)
      })
    } catch (_) {
      el.classList.add('hidden')
      el.innerHTML = ''
    }
  }

  function renderBreadcrumb() {
    const el = document.querySelector('#breadcrumb')
    if (!el) return
    if (!navigationPath.length) {
      el.classList.add('hidden')
      el.innerHTML = ''
      return
    }
    el.classList.remove('hidden')
    el.innerHTML = ''
    navigationPath.forEach((slug, i) => {
      if (i > 0) {
        const sep = document.createElement('span')
        sep.className = 'sep'
        sep.textContent = ' > '
        el.appendChild(sep)
      }
      const page = pagesCache.get(slug)
      const label = page?.title || slug
      const a = document.createElement('a')
      a.href = '#/' + encodeURIComponent(slug)
      a.textContent = label
      a.className = 'wiki-link md-url'
      a.addEventListener('click', (e) => {
        e.preventDefault()
        location.hash = '#/' + encodeURIComponent(slug)
      })
      el.appendChild(a)
    })
  }

  async function compress(string) {
    const byteArray = new TextEncoder().encode(string)
    const stream = new CompressionStream('deflate-raw')
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new Uint8Array(buffer).toBase64({alphabet: 'base64url'})
  }

  async function decompress(b64) {
    const byteArray = Uint8Array.fromBase64(b64, {alphabet: 'base64url'})
    const stream = new DecompressionStream('deflate-raw')
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new TextDecoder().decode(buffer)
  }

  function debounce(ms, fn) {
    let timer
    return (...args) => {
      clearTimeout(timer)
      timer = setTimeout(() => fn(...args), ms)
    }
  }

  async function downloadHTML() {
    updateTitle()
    const doc = document.documentElement.cloneNode(true)
    doc.querySelectorAll('script').forEach(s => s.remove())
    doc.querySelectorAll('.noprint').forEach(s => s.remove())
    doc.querySelector('article').removeAttribute('contenteditable')
    const html = '<!DOCTYPE html>\n' + doc.outerHTML

    if ('showSaveFilePicker' in window) {
      try {
        const handle = await showSaveFilePicker({
          suggestedName: document.title + '.html',
          types: [{
            description: 'HTML file',
            accept: {'text/html': ['.html']},
          }],
        })
        const writable = await handle.createWritable()
        await writable.write(html)
        await writable.close()
        return
      } catch (e) {
        if (e.name === 'AbortError') return
      }
    }

    const blob = new Blob([html], {type: 'text/html'})
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = document.title + '.html'
    a.click()
    URL.revokeObjectURL(url)
  }

  async function downloadTXT() {
    updateTitle()
    const text = article.textContent

    if ('showSaveFilePicker' in window) {
      try {
        const handle = await showSaveFilePicker({
          suggestedName: document.title + '.txt',
          types: [{
            description: 'TEXT file',
            accept: {'text/plain': ['.txt']},
          }],
        })
        const writable = await handle.createWritable()
        await writable.write(text)
        await writable.close()
        return
      } catch (e) {
        if (e.name === 'AbortError') return
      }
    }

    const blob = new Blob([text], {type: 'text/plain'})
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = document.title + '.txt'
    a.click()
    URL.revokeObjectURL(url)
  }

  async function downloadMD() {
    updateTitle()
    const raw = viewMode === 'r' ? getArticleMarkdown() : rawView.value

    if ('showSaveFilePicker' in window) {
      try {
        const handle = await showSaveFilePicker({
          suggestedName: document.title + '.md',
          types: [{
            description: 'Markdown file',
            accept: {'text/markdown': ['.md']},
          }],
        })
        const writable = await handle.createWritable()
        await writable.write(raw)
        await writable.close()
        return
      } catch (e) {
        if (e.name === 'AbortError') return
      }
    }

    const blob = new Blob([raw], {type: 'text/markdown'})
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = document.title + '.md'
    a.click()
    URL.revokeObjectURL(url)
  }

  function parseMarkdown(element) {
    const input = element.textContent
    const frag = document.createDocumentFragment()

    const matchers = [
      {name: 'md-codeblock', re: /```[^\n]*\n[\s\S]*?\n```/y},
      {name: 'md-codeblock', re: /~~~[^\n]*\n[\s\S]*?\n~~~/y},
      {name: 'wiki-link', re: /\[\[([^\]]+?)(?:\|([^\]]+))?\]\]/y},
      {name: 'md-hr', re: /^(?:---|\*\*\*|___)[ \t]*$/my},
      {name: 'md-table', re: /^(\|[^\n]+\|\n\|[-:\s|]+\|\n(?:\|[^\n]+\|\n?)*)/my},
      {name: 'md-blockquote', re: /^([ \t]*>[ \t]?[^\n]+(?:\n[ \t]*>[ \t]?[^\n]+)*)/my},
      {name: 'md-ul', re: /^([ \t]*[-*+][ \t]+[^\n]+(?:\n[ \t]*[-*+][ \t]+[^\n]+)*)/my},
      {name: 'md-ol', re: /^([ \t]*\d+\.[ \t]+[^\n]+(?:\n[ \t]*\d+\.[ \t]+[^\n]+)*)/my},
      {name: 'md-h1', re: /^#[ \t]+[^\n]*$/my},
      {name: 'md-h2', re: /^##[ \t]+[^\n]*$/my},
      {name: 'md-h3', re: /^###[ \t]+[^\n]*$/my},
      {name: 'md-h4', re: /^####[ \t]+[^\n]*$/my},
      {name: 'md-h5', re: /^#####[ \t]+[^\n]*$/my},
      {name: 'md-h6', re: /^######[ \t]+[^\n]*$/my},
      {name: 'md-img', re: /!\[([^\]]*)\]\(([^)]+)\)/y},
      {name: 'md-link', re: /\[([^\]]*)\]\(([^)]+)\)/y},
      {name: 'md-code', re: /`[^`\n]*`/y},
      {name: 'md-bold', re: /\*\*[^*\n]+?\*\*/y},
      {name: 'md-bold', re: /__[^_\n]+?__/y},
      {name: 'md-strike', re: /~~[^~\n]+?~~/y},
      {name: 'md-italic', re: /\*[^*\n]+?\*/y},
      {name: 'md-italic', re: /_[^_\n]+?_/y},
      {name: 'md-url', re: /https?:\/\/[^\s<>()\[\]{}"'`]+/y},
    ]

    const specials = ['`', '~', '*', '#', '_', 'h', '[', '!', '-', '>', '|', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

    let i = 0
    while (i < input.length) {
      let matched = false
      for (const m of matchers) {
        m.re.lastIndex = i
        const res = m.re.exec(input)
        if (res && res.index === i) {
          const raw = res[0]
          if (m.name === 'wiki-link') {
            const slug = res[1].trim()
            const cached = pagesCache.get(slug)
            const autoLabel = cached?.title || slug
            const label = res[2]?.trim() || autoLabel
            const a = document.createElement('a')
            a.className = 'md-url wiki-link'
            a.href = '#/' + encodeURIComponent(slug)
            a.textContent = label
            a.setAttribute('data-wiki-slug', slug)
            frag.appendChild(a)

            const isReferencedAnywhere = !!(referencedSlugsSet && referencedSlugsSet.has(slug))
            const parentSlug = cached?.parent_slug || null
            const isOnParent = parentSlug && parentSlug === currentPageSlug

            if (isReferencedAnywhere && (!parentSlug || !isOnParent)) {
              const sup = document.createElement('sup')
              sup.className = 'ref-indicator'
              sup.setAttribute('aria-label', 'referenced')
              const span = document.createElement('span')
              span.className = 'material-symbols-outlined'
              span.textContent = 'arrow_insert'
              sup.appendChild(span)
              frag.appendChild(sup)
            }
          } else if (m.name === 'md-img') {
            const img = document.createElement('img')
            img.className = 'md-img'
            img.src = res[2]
            img.alt = res[1]
            frag.appendChild(img)
          } else if (m.name === 'md-hr') {
            const hr = document.createElement('hr')
            hr.className = 'md-hr'
            frag.appendChild(hr)
          } else if (m.name === 'md-ul') {
            const ul = document.createElement('ul')
            ul.className = 'md-ul'
            raw.split(/\n/).forEach(line => {
              const m2 = line.match(/^[ \t]*[-*+][ \t]+(.+)$/)
              if (m2) {
                const li = document.createElement('li')
                li.className = 'md-li'
                li.textContent = m2[1]
                ul.appendChild(li)
              }
            })
            frag.appendChild(ul)
          } else if (m.name === 'md-ol') {
            const ol = document.createElement('ol')
            ol.className = 'md-ol'
            raw.split(/\n/).forEach(line => {
              const m2 = line.match(/^[ \t]*\d+\.[ \t]+(.+)$/)
              if (m2) {
                const li = document.createElement('li')
                li.className = 'md-li'
                li.textContent = m2[1]
                ol.appendChild(li)
              }
            })
            frag.appendChild(ol)
          } else if (m.name === 'md-blockquote') {
            const blockquote = document.createElement('blockquote')
            blockquote.className = 'md-blockquote'
            blockquote.textContent = raw.split(/\n/).map(l => l.replace(/^[ \t]*>[ \t]?/, '')).join('\n')
            frag.appendChild(blockquote)
          } else if (m.name === 'md-table') {
            const rows = raw.trim().split(/\n/)
            const table = document.createElement('table')
            table.className = 'md-table'
            const thead = document.createElement('thead')
            const headerCells = rows[0].split('|').filter((_, idx, arr) => idx > 0 && idx < arr.length - 1).map(s => s.trim())
            const trHead = document.createElement('tr')
            headerCells.forEach(c => {
              const th = document.createElement('th')
              th.textContent = c
              trHead.appendChild(th)
            })
            thead.appendChild(trHead)
            table.appendChild(thead)
            const tbody = document.createElement('tbody')
            for (let r = 2; r < rows.length; r++) {
              const cells = rows[r].split('|').filter((_, idx, arr) => idx > 0 && idx < arr.length - 1).map(s => s.trim())
              const tr = document.createElement('tr')
              cells.forEach(c => {
                const td = document.createElement('td')
                td.textContent = c
                tr.appendChild(td)
              })
              tbody.appendChild(tr)
            }
            table.appendChild(tbody)
            frag.appendChild(table)
          } else if (m.name === 'md-link') {
            const a = document.createElement('a')
            a.className = 'md-url'
            a.href = res[2]
            a.textContent = res[1]
            a.target = '_blank'
            a.rel = 'noopener noreferrer'
            frag.appendChild(a)
          } else if (m.name === 'md-url') {
            const a = document.createElement('a')
            a.className = 'md-url'
            a.href = raw
            a.textContent = raw
            a.target = '_blank'
            a.rel = 'noopener noreferrer'
            frag.appendChild(a)
          } else if (/^md-h[1-6]$/.test(m.name)) {
            const span = document.createElement('span')
            span.className = m.name
            span.textContent = raw.replace(/^#+[ \t]+/, '')
            frag.appendChild(span)
          } else if (m.name === 'md-bold') {
            const span = document.createElement('span')
            span.className = m.name
            span.textContent = raw.slice(2, -2)
            frag.appendChild(span)
          } else if (m.name === 'md-strike') {
            const span = document.createElement('span')
            span.className = m.name
            span.textContent = raw.slice(2, -2)
            frag.appendChild(span)
          } else if (m.name === 'md-italic') {
            const span = document.createElement('span')
            span.className = m.name
            span.textContent = raw.slice(1, -1)
            frag.appendChild(span)
          } else if (m.name === 'md-code') {
            const span = document.createElement('span')
            span.className = m.name
            span.textContent = raw.slice(1, -1)
            frag.appendChild(span)
          } else {
            const span = document.createElement('span')
            span.className = m.name
            span.textContent = raw
            frag.appendChild(span)
          }
          i += raw.length
          matched = true
          break
        }
      }

      if (matched) continue

      let next = input.length
      for (const ch of specials) {
        const idx = input.indexOf(ch, i)
        if (idx !== -1 && idx < next) next = idx
      }

      if (next === i) {
        frag.appendChild(document.createTextNode(input[i]))
        i++
        continue
      }

      frag.appendChild(document.createTextNode(input.slice(i, next)))
      i = next
    }

    article.textContent = ''
    article.appendChild(frag)
    article.normalize()
  }

  function serializeToMarkdown(node) {
    if (node.nodeType === Node.TEXT_NODE) return node.nodeValue || ''
    if (node.nodeType !== Node.ELEMENT_NODE) return ''
    const el = node
    if (el.tagName === 'SUP' && el.classList?.contains('ref-indicator')) return ''
    const inner = () => Array.from(el.childNodes).map(serializeToMarkdown).join('')
    if (el.classList?.contains('md-h1')) return '# ' + inner()
    if (el.classList?.contains('md-h2')) return '## ' + inner()
    if (el.classList?.contains('md-h3')) return '### ' + inner()
    if (el.classList?.contains('md-h4')) return '#### ' + inner()
    if (el.classList?.contains('md-h5')) return '##### ' + inner()
    if (el.classList?.contains('md-h6')) return '###### ' + inner()
    if (el.tagName === 'HR' && el.classList?.contains('md-hr')) return '\n---\n'
    if (el.tagName === 'UL' && el.classList?.contains('md-ul')) {
      return '\n' + Array.from(el.querySelectorAll('.md-li')).map(li => '- ' + serializeToMarkdown(li)).join('\n') + '\n'
    }
    if (el.tagName === 'OL' && el.classList?.contains('md-ol')) {
      return '\n' + Array.from(el.querySelectorAll('.md-li')).map((li, idx) => (idx + 1) + '. ' + serializeToMarkdown(li)).join('\n') + '\n'
    }
    if (el.classList?.contains('md-li')) return inner()
    if (el.tagName === 'BLOCKQUOTE' && el.classList?.contains('md-blockquote')) {
      return '\n' + inner().split('\n').map(l => '> ' + l).join('\n') + '\n'
    }
    if (el.tagName === 'TABLE' && el.classList?.contains('md-table')) {
      const rows = Array.from(el.querySelectorAll('tr'))
      const lines = []
      rows.forEach((tr, ri) => {
        const cells = Array.from(tr.querySelectorAll('th, td')).map(c => c.textContent.trim())
        lines.push('| ' + cells.join(' | ') + ' |')
        if (ri === 0) lines.push('| ' + cells.map(() => '---').join(' | ') + ' |')
      })
      return '\n' + lines.join('\n') + '\n'
    }
    if (el.tagName === 'IMG' && el.classList?.contains('md-img')) {
      const alt = el.getAttribute('alt') || ''
      const src = el.getAttribute('src') || ''
      return '![' + alt + '](' + src + ')'
    }
    if (el.tagName === 'A' && el.classList?.contains('wiki-link')) {
      let slug = el.getAttribute('data-wiki-slug')
      if (!slug) {
        try {
          slug = decodeURIComponent((el.getAttribute('href') || '').replace(/^#\/?/, ''))
        } catch (_) {
          slug = inner()
        }
      }
      return '[[' + slug + ']]'
    }
    if (el.tagName === 'A' && el.classList?.contains('md-url')) {
      const text = inner()
      const href = el.getAttribute('href') || el.href
      return text === href ? href : '[' + text + '](' + href + ')'
    }
    if (el.classList?.contains('md-code')) return '`' + inner() + '`'
    if (el.classList?.contains('md-codeblock')) return inner()
    if (el.classList?.contains('md-bold')) return '**' + inner() + '**'
    if (el.classList?.contains('md-strike')) return '~~' + inner() + '~~'
    if (el.classList?.contains('md-italic')) return '*' + inner() + '*'
    return inner()
  }

  function getArticleMarkdown() {
    return Array.from(article.childNodes).map(serializeToMarkdown).join('')
  }

  function initUI() {
    const menu = document.querySelector('#menu')
    const button = document.querySelector('#button')
    const qr = document.querySelector('#qr')
    const shareLink = document.querySelector('#share-link')
    const saveAsHTML = document.querySelector('#save-as-html')
    const saveAsText = document.querySelector('#save-as-text')

    button.addEventListener('click', event => {
      if (event.clientX || event.targetTouches) ripple(event)
      menu.classList.toggle('visible')
      qr.setAttribute('href', '/qr' + location.hash)
      shareLink.setAttribute('href', location.href)
    })

    function hideMenu() {
      menu.classList.remove('visible')
    }

    document.body.addEventListener('click', event => {
      let t = event.target
      if (t.closest('#menu')) return
      if (t.closest('#button')) return
      if (t.closest('.ripple')) return
      menu.classList.remove('visible')
    })

    shareLink.addEventListener('click', event => {
      event.preventDefault()
      if (!navigator.clipboard) {
        alert('Your browser does not support clipboard API')
        return
      }
      navigator.clipboard.writeText(location.href)
      notify('Link copied')
      hideMenu()
    })
    saveAsHTML.addEventListener('click', event => {
      event.preventDefault()
      downloadHTML()
      hideMenu()
    })
    saveAsText.addEventListener('click', event => {
      event.preventDefault()
      downloadTXT()
      hideMenu()
    })

    const allPages = document.querySelector('#all-pages')
    const pagesModal = document.querySelector('#pages-modal')
    const pagesList = document.querySelector('#pages-list')
    const pagesModalClose = document.querySelector('#pages-modal-close')

    if (allPages) {
      allPages.addEventListener('click', async (e) => {
        e.preventDefault()
        hideMenu()
        pagesModal.style.display = 'flex'
        try {
          let pages = []
          if (SUPABASE) {
            pages = await SUPABASE.list()
          } else {
            for (let i = 0; i < localStorage.length; i++) {
              const k = localStorage.key(i)
              if (k?.startsWith('wiki:')) {
                const slug = k.slice(5)
                const row = { slug, title: slug }
                pages.push(row)
                pagesCache.set(slug, row)
              }
            }
          }
          pagesList.innerHTML = pages.length
            ? pages.map(p => `<a href="#/${encodeURIComponent(p.slug)}" style="display:block;padding:8px 0;color:var(--link);">${escapeHtml(p.title || p.slug)}</a>`).join('')
            : '<p style="color:var(--text);opacity:0.7;">No pages yet</p>'
          pagesList.querySelectorAll('a').forEach(a => {
            a.addEventListener('click', () => { pagesModal.style.display = 'none' })
          })
        } catch (err) {
          pagesList.innerHTML = '<p style="color:red;">Could not load pages</p>'
        }
      })
    }
    if (pagesModalClose) {
      pagesModalClose.addEventListener('click', () => { pagesModal.style.display = 'none' })
    }
    if (pagesModal) {
      pagesModal.addEventListener('click', (e) => { if (e.target === pagesModal) pagesModal.style.display = 'none' })
    }
  }

  function escapeHtml(s) {
    const d = document.createElement('div')
    d.textContent = s
    return d.innerHTML
  }

  // --- Wiki-link autocomplete in raw view ---
  let wikilinkStart = null
  let wikilinkPopupEl = null
  let wikilinkResults = []
  let wikilinkSelected = 0
  let wikilinkPagesLoaded = false

  function ensureWikilinkPopup() {
    if (wikilinkPopupEl) return wikilinkPopupEl
    const el = document.createElement('div')
    el.id = 'wikilink-popup'
    el.className = 'noprint'
    el.style.position = 'fixed'
    el.style.minWidth = '260px'
    el.style.maxWidth = '90vw'
    el.style.maxHeight = '50vh'
    el.style.overflow = 'auto'
    el.style.background = 'var(--elevated)'
    el.style.borderRadius = '8px'
    el.style.boxShadow = '0 10px 30px rgba(0,0,0,0.3)'
    el.style.font = '14px / 1.4 "Poppins", sans-serif'
    el.style.display = 'none'
    el.style.zIndex = '100'
    document.body.appendChild(el)
    wikilinkPopupEl = el
    return el
  }

  function positionWikilinkPopup(x, y) {
    const el = ensureWikilinkPopup()
    const gap = 4
    const maxRight = window.innerWidth - 16
    const maxBottom = window.innerHeight - 16
    let left = x
    let top = y + gap
    el.style.left = left + 'px'
    el.style.top = top + 'px'
    el.style.transform = 'none'
    requestAnimationFrame(() => {
      const r = el.getBoundingClientRect()
      if (r.right > maxRight) left = maxRight - r.width
      if (r.bottom > maxBottom) top = y - r.height - gap
      if (top < 8) top = 8
      if (left < 8) left = 8
      el.style.left = left + 'px'
      el.style.top = top + 'px'
    })
  }

  async function loadAllPagesOnce() {
    if (wikilinkPagesLoaded) return
    try {
      if (SUPABASE) {
        await SUPABASE.list()
      } else {
        for (let i = 0; i < localStorage.length; i++) {
          const k = localStorage.key(i)
          if (k?.startsWith('wiki:')) {
            const slug = k.slice(5)
            const row = { slug, title: slug }
            pagesCache.set(slug, row)
          }
        }
      }
      wikilinkPagesLoaded = true
    } catch (_) {
      // ignore
    }
  }

  function genPageId() {
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
      return 'p' + crypto.randomUUID().replace(/-/g, '').slice(0, 12)
    }
    const s = () => Math.random().toString(36).slice(2)
    return 'p' + s() + s().slice(0, 4) + Date.now().toString(36).slice(-4)
  }

  function getCaretCoordinates(textarea, offset) {
    const div = document.createElement('div')
    const style = getComputedStyle(textarea)
    const rect = textarea.getBoundingClientRect()
    div.style.cssText = `
      position: fixed; visibility: hidden; white-space: pre-wrap; word-wrap: break-word;
      overflow: hidden; top: ${rect.top}px; left: ${rect.left}px; width: ${textarea.offsetWidth}px; height: ${textarea.offsetHeight}px;
      font: ${style.font}; padding: ${style.padding}; box-sizing: border-box;
      line-height: ${style.lineHeight}; letter-spacing: ${style.letterSpacing};
    `
    document.body.appendChild(div)
    const text = textarea.value.slice(0, offset)
    div.textContent = text
    const span = document.createElement('span')
    span.textContent = '\u200b'
    div.appendChild(span)
    const spanRect = span.getBoundingClientRect()
    document.body.removeChild(div)
    return { x: spanRect.left, y: spanRect.bottom }
  }

  function handleRawKeydown(e) {
    if (e.key === '[') {
      const { selectionStart, selectionEnd, value } = rawView
      if (selectionStart === selectionEnd && selectionStart >= 1 && value[selectionStart - 1] === '[') {
        // user has just typed '[['
        setTimeout(() => openWikilinkAt(selectionStart - 1), 0)
      }
    }
    if (wikilinkStart !== null && wikilinkPopupEl && wikilinkPopupEl.style.display !== 'none') {
      if (e.key === 'Escape') {
        closeWikilinkPopup()
      } else if (e.key === 'ArrowDown') {
        e.preventDefault()
        if (wikilinkResults.length) {
          wikilinkSelected = (wikilinkSelected + 1) % wikilinkResults.length
          renderWikilinkResults()
        }
      } else if (e.key === 'ArrowUp') {
        e.preventDefault()
        if (wikilinkResults.length) {
          wikilinkSelected = (wikilinkSelected - 1 + wikilinkResults.length) % wikilinkResults.length
          renderWikilinkResults()
        }
      } else if (e.key === 'Enter') {
        if (wikilinkResults.length) {
          e.preventDefault()
          const choice = wikilinkResults[wikilinkSelected]
          if (choice) applyWikilinkChoice(choice)
        }
      }
    }
  }

  function handleRawInputForWikilink() {
    if (wikilinkStart !== null) {
      updateWikilinkQuery()
    }
  }

  function openWikilinkAt(start) {
    wikilinkStart = start
    wikilinkSelected = 0
    ensureWikilinkPopup()
    try {
      const { x, y } = getCaretCoordinates(rawView, start + 2)
      positionWikilinkPopup(x, y)
    } catch (_) {
      positionWikilinkPopup(window.innerWidth / 2 - 130, window.innerHeight - 200)
    }
    wikilinkPopupEl.style.display = 'block'
    updateWikilinkQuery()
  }

  async function updateWikilinkQuery() {
    if (wikilinkStart === null) return
    const caret = rawView.selectionStart
    if (caret < wikilinkStart + 2) {
      closeWikilinkPopup()
      return
    }
    const segment = rawView.value.slice(wikilinkStart + 2, caret)
    if (segment.includes(']') || segment.includes('\n')) {
      closeWikilinkPopup()
      return
    }
    const query = segment.trim()
    await loadAllPagesOnce()
    const all = Array.from(pagesCache.values())
    const lower = query.toLowerCase()
    let matches = all
    if (lower) {
      matches = all.filter(p =>
        p.slug.toLowerCase().includes(lower) ||
        (p.title || '').toLowerCase().includes(lower)
      )
    }
    const choices = matches.map(p => ({
      type: 'existing',
      slug: p.slug,
      title: p.title || p.slug
    }))
    if (query) {
      choices.unshift({
        type: 'new',
        slug: null,
        title: query
      })
    }
    wikilinkResults = choices
    wikilinkSelected = 0
    try {
      const { x, y } = getCaretCoordinates(rawView, rawView.selectionStart)
      positionWikilinkPopup(x, y)
    } catch (_) {}
    renderWikilinkResults()
  }

  function renderWikilinkResults() {
    const el = ensureWikilinkPopup()
    if (!wikilinkResults.length) {
      el.innerHTML = '<div style="padding:8px 12px;opacity:0.7;">No matches</div>'
      return
    }
    el.innerHTML = wikilinkResults.map((c, idx) => {
      const isActive = idx === wikilinkSelected
      const prefix = c.type === 'new' ? 'Create ' : ''
      return `<div data-idx="${idx}" style="padding:6px 12px;cursor:pointer;background:${isActive ? 'rgba(0,0,0,0.1)' : 'transparent'};">${escapeHtml(prefix + (c.title || c.slug))}</div>`
    }).join('')
    Array.from(el.querySelectorAll('div[data-idx]')).forEach(node => {
      node.addEventListener('mousedown', e => {
        e.preventDefault()
        const idx = Number(node.getAttribute('data-idx'))
        const choice = wikilinkResults[idx]
        if (choice) applyWikilinkChoice(choice)
      })
    })
  }

  async function applyWikilinkChoice(choice) {
    let { slug, title, type } = choice
    if (type === 'new') {
      slug = genPageId()
      const t = title || ''
      const initialContent = t ? '# ' + t + '\n\n' : ''
      try {
        await persistToBackend(slug, initialContent, t, currentPageSlug || undefined)
      } catch (_) {}
    }
    const caret = rawView.selectionStart
    const before = rawView.value.slice(0, wikilinkStart)
    const after = rawView.value.slice(caret)
    const insert = '[[' + slug + ']]'
    rawView.value = before + insert + after
    const newPos = before.length + insert.length
    rawView.selectionStart = rawView.selectionEnd = newPos
    closeWikilinkPopup()
  }

  function closeWikilinkPopup() {
    if (wikilinkPopupEl) wikilinkPopupEl.style.display = 'none'
    wikilinkStart = null
    wikilinkResults = []
    wikilinkSelected = 0
  }

  function ripple(event) {
    const button = event.currentTarget
    const circle = document.createElement('span')
    const diameter = Math.max(button.clientWidth, button.clientHeight)
    const radius = diameter / 2
    circle.style.width = circle.style.height = `${diameter}px`
    circle.style.left = `${(event.clientX || event.targetTouches[0].pageX) - button.offsetLeft - radius}px`
    circle.style.top = `${(event.clientY || event.targetTouches[0].pageY) - button.offsetTop - radius}px`
    circle.classList.add('ripple')
    const ripple = button.getElementsByClassName('ripple')[0]
    if (ripple) ripple.remove()
    button.appendChild(circle)
  }

  function Editor(element, highlight) {
    const listeners = []
    const history = []
    let at = -1, prev

    const debounceHighlight = debounce(30, () => {
      const pos = save()
      element.textContent = getArticleMarkdown()
      highlight(element)
      restore(pos)
    })

    const shouldRecord = (event) => {
      return !isUndo(event) && !isRedo(event)
        && event.key !== 'Meta'
        && event.key !== 'Control'
        && event.key !== 'Alt'
        && !event.key.startsWith('Arrow')
    }

    let recording = false
    const debounceRecordHistory = debounce(300, (event) => {
      if (shouldRecord(event)) {
        recordHistory()
        recording = false
      }
    })

    const on = (type, fn) => {
      listeners.push([type, fn])
      element.addEventListener(type, fn)
    }
    on('keydown', event => {
      if (event.defaultPrevented) return
      prev = toString()
      if (isUndo(event)) doUndo(event)
      if (isRedo(event)) doRedo(event)
      if (shouldRecord(event) && !recording) {
        recordHistory()
        recording = true
      }
    })
    on('keyup', event => {
      if (event.defaultPrevented) return
      if (event.isComposing) return
      if (prev !== toString()) debounceHighlight()
      debounceRecordHistory(event)
    })
    on('paste', () => setTimeout(recordHistory, 10))
    on('cut', () => setTimeout(recordHistory, 10))
    on('beforeinput', event => {
      if (event.inputType === 'historyUndo') doUndo(event)
      if (event.inputType === 'historyRedo') doRedo(event)
    })

    function save() {
      const s = getSelection()
      const pos = {start: 0, end: 0, dir: undefined}
      let {anchorNode, anchorOffset, focusNode, focusOffset} = s
      if (!anchorNode || !focusNode) throw 'error1'
      if (anchorNode === element && focusNode === element) {
        pos.start = (anchorOffset > 0 && element.textContent) ? element.textContent.length : 0
        pos.end = (focusOffset > 0 && element.textContent) ? element.textContent.length : 0
        pos.dir = (focusOffset >= anchorOffset) ? '->' : '<-'
        return pos
      }
      if (anchorNode.nodeType === Node.ELEMENT_NODE) {
        const node = document.createTextNode('')
        anchorNode.insertBefore(node, anchorNode.childNodes[anchorOffset])
        anchorNode = node
        anchorOffset = 0
      }
      if (focusNode.nodeType === Node.ELEMENT_NODE) {
        const node = document.createTextNode('')
        focusNode.insertBefore(node, focusNode.childNodes[focusOffset])
        focusNode = node
        focusOffset = 0
      }
      visit(element, el => {
        if (el === anchorNode && el === focusNode) {
          pos.start += anchorOffset
          pos.end += focusOffset
          pos.dir = anchorOffset <= focusOffset ? '->' : '<-'
          return 'stop'
        }
        if (el === anchorNode) {
          pos.start += anchorOffset
          if (!pos.dir) {
            pos.dir = '->'
          } else {
            return 'stop'
          }
        } else if (el === focusNode) {
          pos.end += focusOffset
          if (!pos.dir) {
            pos.dir = '<-'
          } else {
            return 'stop'
          }
        }
        if (el.nodeType === Node.TEXT_NODE) {
          if (pos.dir !== '->') pos.start += el.nodeValue.length
          if (pos.dir !== '<-') pos.end += el.nodeValue.length
        }
      })

      element.normalize()
      return pos
    }

    function restore(pos) {
      const s = getSelection()
      let startNode, startOffset = 0
      let endNode, endOffset = 0

      if (!pos.dir) pos.dir = '->'
      if (pos.start < 0) pos.start = 0
      if (pos.end < 0) pos.end = 0

      if (pos.dir === '<-') {
        const {start, end} = pos
        pos.start = end
        pos.end = start
      }

      let current = 0

      visit(element, el => {
        if (el.nodeType !== Node.TEXT_NODE) return

        const len = (el.nodeValue || '').length
        if (current + len > pos.start) {
          if (!startNode) {
            startNode = el
            startOffset = pos.start - current
          }
          if (current + len > pos.end) {
            endNode = el
            endOffset = pos.end - current
            return 'stop'
          }
        }
        current += len
      })

      if (!startNode) {
        startNode = element
        startOffset = element.childNodes.length
      }
      if (!endNode) {
        endNode = element
        endOffset = element.childNodes.length
      }

      if (pos.dir === '<-') {
        [startNode, startOffset, endNode, endOffset] = [endNode, endOffset, startNode, startOffset]
      }

      {
        const startEl = uneditable(startNode)
        if (startEl) {
          const node = document.createTextNode('')
          startEl.parentNode?.insertBefore(node, startEl)
          startNode = node
          startOffset = 0
        }
        const endEl = uneditable(endNode)
        if (endEl) {
          const node = document.createTextNode('')
          endEl.parentNode?.insertBefore(node, endEl)
          endNode = node
          endOffset = 0
        }
      }

      s.setBaseAndExtent(startNode, startOffset, endNode, endOffset)
      element.normalize()
    }

    function uneditable(node) {
      while (node && node !== element) {
        if (node.nodeType === Node.ELEMENT_NODE) {
          if (node.getAttribute('contenteditable') === 'false') {
            return node
          }
        }
        node = node.parentNode
      }
    }

    function doUndo(event) {
      preventDefault(event)
      at--
      const record = history[at]
      if (record) {
        element.innerHTML = record.html
        restore(record.pos)
      }
      if (at < 0) at = 0
    }

    function doRedo(event) {
      preventDefault(event)
      at++
      const record = history[at]
      if (record) {
        element.innerHTML = record.html
        restore(record.pos)
      }
      if (at >= history.length) at--
    }

    function recordHistory() {
      const html = element.innerHTML
      const pos = save()
      const lastRecord = history[at]
      if (
        lastRecord
        && lastRecord.html === html
        && lastRecord.pos.start === pos.start
        && lastRecord.pos.end === pos.end
      ) return
      at++
      history[at] = {html, pos}
      history.splice(at + 1)
      const maxHistory = 10_000
      if (at > maxHistory) {
        at = maxHistory
        history.splice(0, 1)
      }
    }

    function visit(editor, visitor) {
      const queue = []
      if (editor.firstChild) queue.push(editor.firstChild)
      let el = queue.pop()
      while (el) {
        if (visitor(el) === 'stop') break
        if (el.nextSibling) queue.push(el.nextSibling)
        if (el.firstChild) queue.push(el.firstChild)
        el = queue.pop()
      }
    }

    function isCtrl(event) {
      return event.metaKey || event.ctrlKey
    }

    function isUndo(event) {
      return isCtrl(event) && !event.shiftKey && event.code === 'KeyZ'
    }

    function isRedo(event) {
      return isCtrl(event) && event.shiftKey && event.code === 'KeyZ'
    }

    function toString() {
      return element.textContent || ''
    }

    function preventDefault(event) {
      event.preventDefault()
    }

    function getSelection() {
      return element.getRootNode().getSelection()
    }

    return {
      set(content) {
        element.textContent = content
        highlight(element)
      },
      destroy() {
        for (const [type, fn] of listeners) editor.removeEventListener(type, fn)
      },
    }
  }
</script>
<svg style="display: none" aria-hidden="true" focusable="false">
  <symbol id="icon-plus" viewBox="0 0 24 24" fill="none" stroke="currentColor"
          stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round"
          class="icon icon-tabler icons-tabler-outline icon-tabler-plus">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M12 5l0 14"/>
    <path d="M5 12l14 0"/>
  </symbol>
  <symbol id="icon-share" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.25"
          stroke-linecap="round"
          stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M8 9h-1a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-8a2 2 0 0 0 -2 -2h-1"/>
    <path d="M12 14v-11"/>
    <path d="M9 6l3 -3l3 3"/>
  </symbol>
  <symbol id="icon-qrcode" viewBox="0 0 24 24" fill="none" stroke="currentColor"
          stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M4 5a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1l0 -4"/>
    <path d="M7 17l0 .01"/>
    <path d="M14 5a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1l0 -4"/>
    <path d="M7 7l0 .01"/>
    <path d="M4 15a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1l0 -4"/>
    <path d="M17 7l0 .01"/>
    <path d="M14 14l3 0"/>
    <path d="M20 14l0 .01"/>
    <path d="M14 14l0 3"/>
    <path d="M14 20l3 0"/>
    <path d="M17 17l3 0"/>
    <path d="M20 17l0 3"/>
  </symbol>
  <symbol id="icon-github" viewBox="0 0 24 24" fill="none" stroke="currentColor"
          stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path
      d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"/>
  </symbol>
  <symbol id="icon-empty" viewBox="0 0 24 24"></symbol>
</svg>
